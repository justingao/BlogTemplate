---

layout: post
categories: [Tools]
tags: [jekyll, github, git, markdown]

---

##介绍
［*Show me the code*］活动是我在[算法小站](http://site.douban.com/196781/)中举办的“*编程比赛*”，主要面向算法与数据结构的初学者，答题方式是向我建立的[Github项目](https://github.com/ellochen/Show-me-the-code)上提交自己的代码。这是第二届,题目见[这里](https://github.com/ellochen/Show-me-the-code/tree/master/second)。  
本次题目解析，仅给出简单思路及要点，如需参考详细代码可在github该项目中找到。  

---
###题目解析：
1. **第一题是常见的链表面试题收集**，出处见[这里](http://hit9.org/blog/C/posts/25.html#2)，该博主给出了完整的解答，这里不再赘述。

2. **给你两个链表L1和L2，分别编写函数得到L1与L2的交集和并集。**  
这道题我的本意是出有序链表，忘记写有序两个字了，怪不得abalone用哈希表来实现这个题目，按有序的链表来思考的话不需要那么麻烦，这是我出题的失误。我的代码是按照
有序链表来写的，O(n)复杂度，步骤如下：假设L1，L2的数据都是从大到小排列，设两个指针p1，p2，分别指向L1，L2，求交集的时候就是p1和p2指向的数据比较，哪一个比较大，就向下移动该指针，如：p1 = p1->next; 如果两者数据相同，则视之为交集的元素，添加到交集的列表中。求并集的思路与求交集类似，只不过是每次指针移动之前都会把指针指向的数据添加到并集的链表中。  

3. **有0，1，...,n-1这n个数排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数。求出这个圆圈里剩下的最后一个数字。**  
这就是数据结构书中常见的“约瑟夫环”。常见的解法当然是用循环链表来模拟，但实际上它有一个不需要链表的美妙的解法，可惜这里空白的地方太小，写不下。额，开玩笑呢，当然要写，我是在吐槽费马=。=  

4. **用链表实现多项式的加法与乘法。可以使用如下结构作为节点：**  
		struct Node{
			int Coefficient;//系数
			int Exponent;//指数
			struct Node* Next;
		};