---

layout: post
categories: [Algorithm]
tags: [算法竞赛, 数据结构, 区间, 字符串]

---

想起那天听到线段树、树状数组、AC自动机...的时候，夕阳下脸上被映红的苦笑，那是我逝去的青春......  

###优先队列  
优先队列的概念很好理解，简单来说，它是保证每次出队的元素是队列中最大（小）元素的队列，在STL里面有现成的实现 `priority_queue` ，STL的使用我就不必讲了，本文主要侧重于各种使用数据结构的概念及原理。  

如果让你来实现这样一个功能，你要怎样实现，有一个想法是先把队列元素排个序就可以了，然而还要考虑作为一个队列是需要很多次入队操作的，如果基于有序数组的实现，每次入队都要重新排列整个队列，复杂度是O（n）。  

有没有更快的方式呢，如果你数据结构没忘光是不是会想起**二叉查找树**呢（后面我会专门讲到），名字好难听，都是二叉一族的...,二叉查找树也叫有序查找树，它可以在插入的时候保证数据的有序性，且插入的期望时间复杂度是O（log n），二叉查找树除叶子结点外的每一个结点的值，都大于它的左子结点，小于它的右子结点，所以最左面的叶子结点就是整棵树的最小结点，在优先队列的应用中每次只要找到这个结点并删除它就可以完成出队操作，期望时间复杂度也是O（log n）。  

二叉查找树其实并不是最好的选择，因为它有可能退化成线性链表，此时的插入删除复杂度为O（n），如果使用平衡树，比如AVL树或是红黑树倒是可以解决这个问题，但是实现起来又过于复杂，有木有一个高效简洁的实现方案呢？  

**二叉堆（binary heap）**，它是解决这个问题的巧妙方案，二叉堆也是树，是一种**完全二叉树**，也就是说除最后一层外，其他层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点。我们看一下二叉堆的概念和实现。  

二叉堆的主要属性是，父亲的值永远大（小）于儿子，具体是大还是小，要看你应用场景是需要最大堆还是最小堆了。就如同二叉查找树一样，保证这个属性的关键在于插入和删除时候对结点的处理，我找几个图来讲这两个过程：  

![图1](https://raw2.github.com/ellochen/Img-store/master/heap1.png)  
![图2](https://raw2.github.com/ellochen/Img-store/master/heap2.png)  

以上两图是在最小堆中插入14的过程，由于是完全二叉树，所以插入一个元素后，堆的最下层最右侧一定会多出一个空位，先尝试把14填到该空位中，发现14比父节点31要小，不符合最小堆的特性，于是我们将31移到下面空位，空出自己的位置作为新空位，依次类推，14尝试填到新的空位依旧比它的父节点21要小，于是再次把21移到下面空位，留出新的空位，此时14放到空位处恰好满足最小堆的特性，插入任务达成。说白了就是小人物不断攀爬把前辈一个个踩到脚底下从而走上人生巅峰的过程，说好听点叫做：**percolate up**。  

![图3](https://raw2.github.com/ellochen/Img-store/master/heap3.png)  
![图4](https://raw2.github.com/ellochen/Img-store/master/heap4.png)  
![图5](https://raw2.github.com/ellochen/Img-store/master/heap5.png)  

以上三图是在最小堆中删除根节点也就是最小项13的过程，由于是完全二叉树，删除一个元素后，堆最下层最右侧的元素31必定要拿开放到其他位置，堆中删除元素的过程实际上就是给31这哥们找个地方安置的过程，首先要把根节点的13给踢开留下一个空位，我们试着把31放进去发现31比13执政时期的左膀右臂14和16都要大，所以不可行，那么选择数值较小的14移到上面的空位去，留下自己的位置作为新的空位，依次类推，把31放进新空位依旧不可行，于是把14的子节点中数值较小的19移上去，留下新空位，此空位依旧容不下31，将下面较小的26移上去，又留下新空位，此时31放到这里恰到好处，于是删除根节点任务达成。这个过程叫做：**percolate down**。  

二叉堆的特性讲完了，看来已经完美支持优先队列的功能了，入队操作就是二叉堆的插入，出队操作就是二叉堆的删除根节点。看起来似乎并不复杂，那么如何实现呢？之前我多次强调二叉堆是完全二叉树，根据完全二叉树的特性，它可以用数组来实现，给每个结点顺次编号，每一个结点左儿子的编号等于自己编号*2，右儿子的编号等于自己编号*2+1。如图所示：  

![图6](https://raw2.github.com/ellochen/Img-store/master/heap8.png)  
![图7](https://raw2.github.com/ellochen/Img-store/master/heap9.png)  

上图数组中的元素对应着堆中的结点。具体实现网上一大把，在此不详述了。  
这里留几道与优先队列相关的题目：  

- [Expedition](http://poj.org/problem?id=2431)  
- [Fence Repair](http://poj.org/problem?id=3253)  
- [Argus](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=247&page=show_problem&problem=3644)  
- [K Smallest Sums](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=229&page=show_problem&problem=3148)  

###并查集  
并查集这个名字看起来很拽的样子，其实它很简单，顾名思义，它实现的功能是集合中的合并和查找功能。  

- 合并元素a和元素b各自所在的集合。  
- 查询元素a和元素b是否属于同一组。  



###树状数组  

###线段树  

###Trie

###KMP 算法

###Aho-Corasick 自动机  

###后缀数组  

###最长公共前缀 （LCP）  

###二叉查找树  
1. Treap
2. 伸展树
