---

layout: post
categories: [Algorithm]
tags: [算法竞赛, 数据结构, 区间, 字符串]

---

想起那天听到线段树、树状数组、AC自动机...的时候，夕阳下脸上被映红的苦笑，那是我逝去的青春......  

###优先队列  
优先队列的概念很好理解，简单来说，它是保证每次出队的元素是队列中最大（小）元素的队列，在STL里面有现成的实现 `priority_queue` ，STL的使用我就不必讲了，本文主要侧重于各种使用数据结构的概念及原理。  

如果让你来实现这样一个功能，你要怎样实现，有一个想法是先把队列元素排个序就可以了，然而还要考虑作为一个队列是需要很多次入队操作的，如果基于有序数组的实现，每次入队都要重新排列整个队列，复杂度是O（n）。  

有没有更快的方式呢，如果你数据结构没忘光是不是会想起**二叉查找树**呢（后面我会专门讲到），名字好难听，都是二叉一族的...,二叉查找树也叫有序查找树，它可以在插入的时候保证数据的有序性，且插入的期望时间复杂度是O（log n），二叉查找树除叶子结点外的每一个结点的值，都大于它的左子结点，小于它的右子结点，所以最左面的叶子结点就是整棵树的最小结点，在优先队列的应用中每次只要找到这个结点并删除它就可以完成出队操作，期望时间复杂度也是O（log n）。  

二叉查找树其实并不是最好的选择，因为它有可能退化成线性链表，此时的插入删除复杂度为O（n），如果使用平衡树，比如AVL树或是红黑树倒是可以解决这个问题，但是实现起来又过于复杂，有木有一个高效简洁的实现方案呢？  

**二叉堆（binary heap）**，它是解决这个问题的巧妙方案，二叉堆也是树，是一种完全二叉树，好好的玉树临风它不要，非要叫什么难听的二叉堆，想不明白...好了我们看一下二叉堆的概念和实现。  

二叉堆的主要属性是，父亲的值永远大（小）于儿子，具体是大还是小，要看你应用场景是需要最大堆还是最小堆了。就如同二叉查找树一样，保证这个属性的关键在于插入和删除时候对结点的处理，我画个图来讲这两个过程：  


###并查集  

###树状数组  

###线段树  

###Trie

###KMP 算法

###Aho-Corasick 自动机  

###后缀数组  

###最长公共前缀 （LCP）  

###二叉查找树  
1. Treap
2. 伸展树
